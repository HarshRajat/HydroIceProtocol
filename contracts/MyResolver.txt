pragma solidity ^0.5.0;


import "./SnowflakeResolver.sol";
import "./SnowflakeInterface.sol";
import "./stringSet.sol";
import "./SafeMath.sol";
import "./IdentityRegistryInterface.sol";
//import "./ERC1155Mintable.sol";
import "./IERC1155Mintable.sol";


// Use cases:
// -registry of snowflake to this resolver
// -mint new NFT of Art, with the required data.
// -put on sale: give a price and change state
// -sell to other SnowflakeResolver
// -list my owned tokens

 
contract ArtOperatorResolver is SnowflakeResolver {
    //Revision history
    //v0.1:
    //   -initial release
    //v0.2:
    //   -changed ERC1155Mintable to allow passing creator address 
    //v0.4:
    //   - delegate call
    //v0.5:
    //   - working as an operator, no delegate calls
    //v0.6 
    //   - approving operator by delegatecall
    //v0.7
    //   - call instead delegatecall
    //v0.8
    //   - snowflake address must do an approval call to erc1155 before be allowed to buy
    //     from an address, as erc1155 standard says.
    //v0.9
    //   - Added TokenHistory event and throws to see history of an Art
    //v1.0
    //   - changed method getFavoriteToken to getFavoriteTokens 

    using SafeMath for uint;
 
 
    IERC1155Mintable public nftAddress;
    SnowflakeInterface public snowflake;
    IdentityRegistryInterface public identityRegistry;
 
    constructor (address snowflakeAddress, address _nftAddress)
        SnowflakeResolver(
            "Digital Art Ownership Resolver v1.0.",
            "Register or trade on Blockchain your owned Digital Art", snowflakeAddress, true, false) 
    public
    {  
          nftAddress = IERC1155Mintable(_nftAddress);
          snowflake = SnowflakeInterface(snowflakeAddress);
          identityRegistry = IdentityRegistryInterface(snowflake.identityRegistryAddress());
    }
    
    //on-sale token ids: array de tokenIds
    //onSaleTokens[0] = 17 => tokenId:17 is on-sale
    //onSaleTokens.length=3 => there are three tokens on-sale
    uint256[] private onSaleTokens;
    
     //enums
    enum ArtStatus {None, OnSale }
    
    //on-sell token data: array de OnSaleToken
    struct ArtToken{
        uint256 tokenId; //pointer to erc1155 tokenId 
        ArtStatus status;
        uint price;
        string uri;
        string name;
        string desc;
        string imgUrl;
        uint256 ownerEIN;
    }
    
    //pets registry by petId(PK)
    mapping (uint256 => ArtToken)  private arts; //

    uint totalArts;
    
    //EIN => token list; this is needed because snowflake can have more than one address
    mapping (uint256 => uint256[]) private ownersOfArt;
    
     //Owner Fields
    struct Artist{
        //string snowflakeId; //PK
        //uint ein; //PK
        string artistName;
    }

    //one hydro is represented as 1000000000000000000
    uint private signUpFee = uint(1).mul(10**18);

    //owners registry by ein
    mapping (uint => Artist) private artists;
    
    //modifiers
    
    modifier _isResolverFor(){
        uint256 EIN = identityRegistry.getEIN(msg.sender);
        require(identityRegistry.isResolverFor(EIN,address(this)),"The EIN has not set this resolver.");
        _;
    }
    
    //only can buy if:
    //snowflake funds >= reward
    //and  reward <= snowflake resolver allowance
    modifier _canBuy(uint tokenId){
        require(arts[tokenId].status == ArtStatus.OnSale,"Art must be On-Sale");
        uint price =  arts[tokenId].price;   
        require(price >=0,"Token must have a price > 0.");
        if(price > 0){
            uint256 buyerEIN = identityRegistry.getEIN(msg.sender);
            require(snowflake.resolverAllowances(buyerEIN,address(this)) >= price,"The sender has no allowance to buy the token.");
            require(snowflake.deposits(buyerEIN) >= price,"The sender has no funds to buy the token");
        }
        _;   
    }
    /*
   function setApprovalForAllCall(address _to) 
   public
   returns (bool){

        //This delegated call to erc1155 allows create and give permission to the resolver 
        //in one transaction. When buy operations made from resolver, it will be allowed.
        bytes memory payload = 
            abi.encodeWithSignature("setApprovalForAll(address,bool)", _to,true);
        (bool success, bytes memory returnData) = address(nftAddress).delegatecall(payload);
        return success;
   }*/   
 
 /*
   function setApprovalForAllDelegatedCall(address _to) 
   public
   returns (bool){


        //This delegated call to erc1155 allows create and give permission to the resolver 
        //in one transaction. When buy operations made from resolver, it will be allowed.
        bytes memory payload = 
            abi.encodeWithSignature("setApprovalForAll(address,bool)", _to,true);
        (bool success, bytes memory returnData) = address(nftAddress).delegatecall(payload);
        return success;
   }
   */
   
      //=================================================================
   // Create an Art and associated NFT
   // Metadata of art in json format must be stored at _uri.
   //=================================================================
   /*
   function createCall(string memory _uri) 
   public
     returns (uint256 _id){

        //delegated creation of token
        bytes memory callToCreate = abi.encodeWithSignature("create(uint256,string)",1,_uri);
        (bool successCreate,bytes memory returnDataCreate) = 
            address(nftAddress).call(callToCreate);
        require(successCreate);
        
        uint256 id = abi.decode(returnDataCreate, (uint256));
       

       return id;
   }
   */
   /*
     function createDelegatedCall(string memory _uri) 
   public
     returns (uint256 _id){

        //delegated creation of token
        bytes memory callToCreate = abi.encodeWithSignature("create(uint256,string)",1,_uri);
        (bool successCreate,bytes memory returnDataCreate) = 
            address(nftAddress).delegatecall(callToCreate);
        require(successCreate);
        
        uint256 id = abi.decode(returnDataCreate, (uint256));
       

       return id;
   }
   */
   
     //=================================================================
   // Create an Art and associated NFT
   // Metadata of art in json format must be stored at _uri.
   //=================================================================
   /*
   function createAndApprovalAllDelegated(string memory _uri, string memory _name, string memory _desc, string memory _imgUrl) 
   public
   _isResolverFor()
   returns (uint256 _id){


        //This delegated call to erc1155 allows create and give permission to the resolver 
        //in one transaction. When buy operations made from resolver, it will be allowed.
        bytes memory payload = 
            abi.encodeWithSignature("setApprovalForAll(address,bool)", address(this),true);
        (bool success, bytes memory returnData) = address(nftAddress).call(payload);
        require(success);

        //delegated creation of token
        bytes memory callToCreate = abi.encodeWithSignature("create(uint256,string)",1,_uri);
        (bool successCreate,bytes memory returnDataCreate) = 
            address(nftAddress).call(callToCreate);
        require(successCreate);
        
        uint256 id = abi.decode(returnDataCreate, (uint256));
        
        //algo mas que hacer al crear?
        arts[id] =  ArtToken({
            tokenId:id,
            status:ArtStatus.None,
            price:0,
            uri:_uri,
            name:_name,
            desc:_desc,
            imgUrl:_imgUrl,
            ownerEIN:identityRegistry.getEIN(msg.sender)  //hydroID of sender
        });
        totalArts++;
        
        //register owner of art by EIN
        ownersOfArt[arts[id].ownerEIN].push(id);

       return id;
   }
   */
   
 //get a token by id
  function getArt(uint256 _id)
  public view
  returns(ArtStatus status, uint256 price, string memory name, string memory desc, string memory imgUrl, uint256 ownerEIN) 
    {
       return( 
            arts[_id].status,
            arts[_id].price, 
            arts[_id].name, 
            arts[_id].desc, 
            arts[_id].imgUrl,
            arts[_id].ownerEIN
        );
    }
  
   //=================================================================
   // Create an Art and associated NFT
   // Metadata of art in json format must be stored at _uri.
   //=================================================================
   function createArt(string memory _uri, string memory _name, string memory _desc, string memory _imgUrl) 
   public
   _isResolverFor()
   returns (uint256 _id){

        //created by operator, that must be allowed
        uint256 id = nftAddress.create(1,_uri);
        
        //transferred from operator to artist
        bytes memory data;
        nftAddress.safeTransferFrom(address(this), msg.sender,id, 1, data);  
        
          
        //This delegatecall to erc1155 allows create and give permission to the resolver 
        //in one transaction. When buy operations made from resolver, it will be allowed.
        //bytes memory payload = abi.encodeWithSignature("setApprovalForAll(address,bool)", address(this),true);
//(bool success, bytes memory returnData) = address(nftAddress).delegatecall(payload);
//require(success);
       

        //hydroID of sender
        uint256 EIN = identityRegistry.getEIN(msg.sender);
        
        //algo mas que hacer al crear?
        ArtToken memory newArt =  ArtToken({
            tokenId:id,
            status:ArtStatus.None,
            price:0,
            uri:_uri,
            name:_name,
            desc:_desc,
            imgUrl:_imgUrl,
            ownerEIN:EIN
        });
        arts[id] = newArt;
        totalArts++;
        
        //register owner of art by EIN
        ownersOfArt[EIN].push(id);
        
        emit TokenHistory(id, now, 0, EIN, 0, 'createArt');

       return id;
   }
    //=================================================================
   // Token owner put one of their tokens OnSale
   // uin256 tokenId: id of art token on-sale
   //=================================================================
   function putOnSale(uint256 tokenId,uint price)
   public
   _isResolverFor()
   returns(bool){
       //verify sender is owner of tokenId
       require(nftAddress.balanceOf(msg.sender,tokenId)==1);
       //not previously on-sale
       require(arts[tokenId].status != ArtStatus.OnSale);
       //change status
       arts[tokenId].status = ArtStatus.OnSale;
       arts[tokenId].price = price;
       
       //store list of current onSale tokens
       onSaleTokens.push(tokenId);
       
        emit TokenHistory(tokenId, now, arts[tokenId].ownerEIN, arts[tokenId].ownerEIN,price, 'putOnSale');
       return true;
   }
   
   //get a list of on-sale tokens
   function getOnSaleTokens()
   public view
   returns ( uint256[] memory){
       return onSaleTokens;
   }
   
   //=================================================================
   // Snowflake user push the button to buy an on-sale art
   // uin256 tokenId: id of art token on-sale
   //=================================================================
   function buyArt(uint256 tokenId)
    public
    _isResolverFor()
   _canBuy(tokenId)   //sender must have funds to pay price of token
    returns(bool){
     
       //payment between snowflakeAddress
       uint price = arts[tokenId].price;
      uint256 ownerEIN = arts[tokenId].ownerEIN;
       snowflake.transferSnowflakeBalance(arts[tokenId].ownerEIN,price.mul(10**18)); 
     
       //transfer of token ownership
       address owner = nftAddress.getCreator(tokenId);
       bytes memory extraData;
       //aprovalForAll
       
       nftAddress.safeTransferFrom(owner,msg.sender,tokenId,1,extraData);
       
        //change status
       arts[tokenId].price =0;
       arts[tokenId].status = ArtStatus.None;
        //hydroID of buyer
        uint256 EINBuyer = identityRegistry.getEIN(msg.sender);
       arts[tokenId].ownerEIN = EINBuyer;
       
       //update ownership of token
       updateOwnershipOfToken(tokenId,ownerEIN,EINBuyer);
       
       //update new owner
       removeFromOnSale(tokenId);
       
        emit TokenHistory(tokenId, now, ownerEIN, EINBuyer,price, 'buyArt');
       return true;
   }
   
  
   //utility method to fix ownersOfArt data after owner changed
    function updateOwnershipOfToken(uint tokenId, uint oldOwner, uint newOwner) 
    private 
    returns(bool success){
        require(ownersOfArt[oldOwner].length>0);
        ownersOfArt[newOwner].push(tokenId);
        for(uint i=0;i<ownersOfArt[oldOwner].length;i++){
            if(ownersOfArt[oldOwner][i] == tokenId){
                ownersOfArt[oldOwner][i] = ownersOfArt[oldOwner][ownersOfArt[oldOwner].length-1];
                ownersOfArt[oldOwner].length--;
                return true;
            }
        }
        return false;
    }
    
     //utility method to fix onSaleTokens data after remove on-sale
    function removeFromOnSale(uint tokenId) 
    private 
    returns(bool success){
        
        for(uint i=0;i<onSaleTokens.length;i++){
            if(onSaleTokens[i] == tokenId){
                onSaleTokens[i] = onSaleTokens[onSaleTokens.length-1];
                onSaleTokens.length--;
                return true;
            }
        }
        return false;
    }
    
  
   
   //==============================================================
   //List if tokens owned by a snowflake (can be several addresses)
   //===============================================================
    function getOwnedTokens(uint256 _EIN)
    public  view
    returns ( uint[] memory)
    {
        return ownersOfArt[_EIN];
    }
     
    //favorites
    //Every ein has a list of favorite tokens: 
    mapping (uint256 =>  uint256[]) private likesOfEIN; 
    uint256 likesOfEIN_index;
   
    
    //Every token has a list of liken EINs
    //we need to know if a token is favorite of EIN:
    // EINsOfLikes[_tokenId][EIN] == true
    mapping (uint256 => mapping (uint256 => bool)) private EINsOfLikes; 
    
    //Every token has a likes count
    mapping (uint => uint) private likeCountOfTokenId;
    
    //==============================================================
   //Mark art as favorite of a snowflake; transactions must be with sender
   //===============================================================
   function addFavorite(uint256 _tokenId)
   public
    _isResolverFor()
   returns (bool)
   {
        uint256 EIN = identityRegistry.getEIN(msg.sender);
        //flag as favorite of this EIN
        likesOfEIN[EIN].push(_tokenId);
        //increment favorite count of token
        likeCountOfTokenId[_tokenId]++;
        
        //flags a EIN as a liker of a token
        EINsOfLikes[_tokenId][EIN] = true;

        
        return true;
   }
   
   function isFavorite(uint256 _tokenId, uint256 _EIN)
   public view
   returns (bool){
        return (EINsOfLikes[_tokenId][_EIN] == true);
   }
   
   //return favorite tokens of sender
   function getFavoriteTokens(uint256 _EIN)
   public view
    returns(uint256[] memory)
    {
       return likesOfEIN[_EIN];
   }

    function getLikesOfToken(uint256 _id)
    public view
    returns (uint256){
        return likeCountOfTokenId[_id];
    }
    
    
    //Events
  event LogDebug(string msg);
  
  event TokenHistory(uint indexed tokenId, uint date, uint from, uint to, uint price, string operation);
  
    // implement signup function
    function onAddition(uint ein, uint, bytes memory) 
    public 
    senderIsSnowflake() 
    returns (bool) {
        //snowflake.withdrawSnowflakeBalanceFrom(ein, owner(), signUpFee);

        //3. update the mapping owners
        // (string memory artistName) = abi.decode(extraData, (string));
        artists[ein].artistName = "artistName";
    
        //emit StatusSignUp(ein);
        return true;
    }
     
    function onRemoval(uint, bytes memory) 
    public 
    senderIsSnowflake() returns (bool) {
        //for every owned token:
        //send to 0x0 address 
        
       
        //return all escrow if any
        //delete owner
         return true;
    }


    
    function getArtist()
    public  view
    returns (string memory ){
        uint256 EIN = identityRegistry.getEIN(msg.sender);
        return( artists[EIN].artistName)  ;  
    }
    
    
    function updateArtist(string memory artistName) 
    public
    _isResolverFor()
    returns (bool success)
    {
        uint256 EIN = identityRegistry.getEIN(msg.sender);
        artists[EIN].artistName = artistName;
        
        return(true);
    }
    
    
   
}